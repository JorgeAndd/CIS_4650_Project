%locations

%{
	#include <stdlib.h>
	#include <stdio.h>
	#include <stdarg.h>
	#include <string.h>
	
	#include "nodes.h"
	
	extern int yylineno;
	extern char *yytext;
	extern char linebuf[150];
	extern int tokenpos;
	
	Program *root;
	
%}

%union{
	int ival;
	float fval;
	char cval;
	char *sval;
	
	Program *programval;
	VarDecl *vardeclval;
	TypeDecl *typedeclval;
	List *listval;
	Stmt *stmtval;
	Expr *exprval;
	Var *varval;
	IdName *idval;
	TypeName *typeval;
	Function *funcval;
	FunctionBody *funcbodyval;
	Param *paramval;
	
}

%type <programval> program
%type <typedeclval> type_decl struct_decl
%type <listval> type_decl_list_start type_decl_list call_param_list_start call_param_list 
%type <listval> var_decl_list_start var_decl_list stmt_list function_def_list
%type <listval> id_list
%type <listval> param_list_start param_list
%type <stmtval> stmt 
%type <stmtval> if_stmt return_stmt iter_stmt compound_stmt
%type <exprval> expr function_call constant iter_expr
%type <varval> var
%type <vardeclval> var_decl
%type <idval> id_name
%type <typeval> type_name

%type <funcval> function_def
%type <funcbodyval> func_body
%type <paramval> param_decl

%type <ival> INT
%token <fval> FLOAT
%token <cval> CHAR
%type <sval> NAME

%define parse.error verbose

%token EQUAL DIFF GE LE
%token AND OR NOT
%token TYPEDEF ASSIGN SIZEOF
%token TKINT TKFLOAT TKCHAR
%token INC DEC
%token IF ELSE FOR WHILE RETURN VOID STRUCT

%token NAME
%token INT

%nonassoc THEN
%nonassoc ELSE
%nonassoc '('

%right ASSIGN
%left OR
%left AND
%left EQUAL DIFF
%left '<' '>' GE LE
%left '+' '-'
%left '*' '/' '%' 
%right SIZEOF NOT UNMINUS UNPLUS
%left INC DEC
%left '.' 
%left '[' 

%%
program	: type_decl_list_start
			{ $$ = Program_create($1, NULL, NULL); root = $$; }
		| type_decl_list_start var_decl_list function_def_list
			{ $$ = Program_create($1, $2, $3); root = $$; }
		| type_decl_list_start var_decl_list
			{ $$ = Program_create($1, $2, NULL); root = $$; }
		| type_decl_list_start function_def_list
			{ $$ = Program_create($1, NULL, $2); root = $$; }
		;	

/*Rule for the basics type: int, float and char	*/
type_name	: TKINT 
				{ $$ = PrimitiveTypeName_create(TYPE_INT); }
			| TKFLOAT
				{ $$ = PrimitiveTypeName_create(TYPE_FLOAT); }
			| TKCHAR		
				{ $$ = PrimitiveTypeName_create(TYPE_FLOAT); }
			| NAME
				{ $$ = UserTypeName_create($1); }
			;

type_decl_list_start	: type_decl_list
							{ $$ = $1; }
						|
							{ $$ = NULL; }
						;

type_decl_list	: type_decl ';'
					{ $$ = TypeDeclList_create($1, NULL); }
				| type_decl_list type_decl ';'
					{ $$ = TypeDeclList_create($2, $1); }
;

type_decl	: TYPEDEF type_name NAME
				{ $$ = Typedef_create($2, $3); }
			| TYPEDEF struct_decl
				{ $$ = $2; }
			;

struct_decl	: STRUCT '{' var_decl_list_start '}' NAME
				{ $$ = Struct_create($3, $5); }
			;
			
var_decl_list_start	: var_decl_list
						{ $$ = $1; }
					|
						{ $$ = NULL; }
					;

var_decl_list	: var_decl_list var_decl ';'
					{ $$ = VarDeclList_create($2, $1); }
				| var_decl ';'
					{ $$ = VarDeclList_create($1, NULL); }
				;

var_decl	: type_name id_list
				{ $$ = VarDecl_create($1, $2); }
			;

id_list	: id_list ',' id_name
			{ $$ = IdList_create($3, $1); }
		| id_name
			{ $$ = IdList_create($1, NULL); }
		;	
		
id_name : NAME
			{ $$ = SimpleIdName_create($1); }
		| NAME '[' INT ']'
			{ $$ = SubscriptIdName_create($1, $3); }
						
function_def_list	: function_def
						{ $$ = FunctionList_create($1, NULL); }
					| function_def_list function_def
						{ $$ = FunctionList_create($2, $1); }
					;
					
function_def	: type_name NAME '(' param_list_start ')' '{' func_body '}'
					{ $$ = Function_create($1, $2, $4, $7); }
				| VOID NAME '(' param_list_start ')' '{' func_body '}'
					{ TypeName *new = PrimitiveTypeName_create(TYPE_VOID);
		   			  $$ = Function_create(new, $2, $4, $7); }
				;

param_list_start	: param_list
						{ $$ = $1; }
					|
						{ $$ = NULL; }
					;

param_list	: param_list ',' param_decl
				{ $$ = ParamList_create($3, $1); }
			| param_decl
				{ $$ = ParamList_create($1, NULL); }
			;

param_decl	: type_name id_name
				{ $$ = Param_create($1, $2); }
;
			
func_body	: var_decl_list stmt_list
				{ $$ = FunctionBody_create($1, $2); }
			| var_decl_list
				{ $$ = FunctionBody_create($1, NULL); }
			| stmt_list
				{ $$ = FunctionBody_create(NULL, $1); }
			|
				{ $$ = FunctionBody_create(NULL, NULL); }
			;

				
stmt_list	: stmt_list stmt
				{ $$ = StmtList_create($2, $1); }
			| stmt
				{ $$ = StmtList_create($1, NULL); }
			;
			

stmt	: expr ';'
			{ $$ = ExpressionStmt_create($1); }
		| compound_stmt
			{ $$ = $1; }
		| if_stmt
			{ $$ = $1; }
		| iter_stmt
			{ $$ = $1; }
		| return_stmt
			{ $$ = $1; }
		;
		
compound_stmt	: '{' stmt_list '}'
					{ $$ = CompoundStmt_create($2); }
				| '{' '}'
					{ $$ = NULL; }
;

if_stmt : IF '(' expr ')' stmt			%prec THEN
				{ $$ = IfStmt_create($3, $5, NULL); }
			| IF '(' expr ')' stmt ELSE stmt
				{ $$ = IfStmt_create($3, $5, $7); }
;

iter_stmt	: WHILE '(' expr ')' stmt 
				{ $$ = IterativeStmt_create(NULL, $3, NULL, $5); }
			| FOR '(' iter_expr ';' iter_expr ';' iter_expr ')' stmt 
				{ $$ = IterativeStmt_create($3, $5, $7, $9); }
			;

iter_expr	: expr
				{ $$ = $1; }
			|
				{ $$ = NULL; }
			;		

return_stmt	: RETURN expr ';'
				{ $$ = ReturnStmt_create($2); }
			| RETURN ';'
				{ $$ = ReturnStmt_create(NULL); }
;
			
function_call	: NAME '(' call_param_list_start ')'
					{ $$ = CallExpr_create($1, $3); }
				;

call_param_list_start	: call_param_list
							{ $$ = $1; }
						|  
							{ $$ = NULL; }
						;
							
call_param_list	: call_param_list ',' expr
					{ $$ = ExprList_create($3, $1); }
				| expr
					{ $$ = ExprList_create($1, NULL); } 
				;
	
				
expr	: expr '+' expr
			{ $$ = BinaryExpr_create($1, OP_ADD, $3); }
		| expr '-' expr
			{ $$ = BinaryExpr_create($1, OP_SUB, $3); }
		| expr '*' expr
			{ $$ = BinaryExpr_create($1, OP_MULT, $3); }
		| expr '/' expr
			{ $$ = BinaryExpr_create($1, OP_DIV, $3); }
		| expr '%' expr
			{ $$ = BinaryExpr_create($1, OP_MOD, $3); }
		| expr '>' expr
			{ $$ = BinaryExpr_create($1, OP_GT, $3); }
		| expr '<' expr
			{ $$ = BinaryExpr_create($1, OP_LT, $3); }
		| expr GE expr
			{ $$ = BinaryExpr_create($1, OP_GE, $3); }
		| expr LE expr
			{ $$ = BinaryExpr_create($1, OP_LE, $3); }
		| expr DIFF expr
			{ $$ = BinaryExpr_create($1, OP_DIFF, $3); }
		| expr EQUAL expr
			{ $$ = BinaryExpr_create($1, OP_EQUAL, $3); }
		| expr OR expr
			{ $$ = BinaryExpr_create($1, OP_OR, $3); }
		| expr AND expr
			{ $$ = BinaryExpr_create($1, OP_AND, $3); }
		| NOT expr 
			{ $$ = UnaryExpr_create(OP_NOT, $2); }
		| '-' expr %prec UNMINUS
			{ $$ = UnaryExpr_create(OP_MINUS, $2); }
		| '+' expr %prec UNPLUS
			{ $$ = UnaryExpr_create(OP_PLUS, $2); }
		| '(' expr ')'
			{ $$ = $2; }
		| function_call
			{ $$ = $1; }
		| var ASSIGN expr
			{ $$ = AssignExpr_create($1, $3); }
		| var
			{ $$ = VarExpr_create($1); }
		| expr INC
			{ $$ = PreOpExpr_create(OP_INC, $1); }
		| expr DEC
			{ $$ = PreOpExpr_create(OP_DEC, $1); }
		| INC expr
			{ $$ = PostOpExpr_create($2, OP_INC); }
		| DEC expr
			{ $$ = PostOpExpr_create($2, OP_DEC); }
		| SIZEOF '(' expr ')'
			{ $$ = SizeOfExpr_create($3); }
		| constant
			{ $$ = $1; }
;
		
var	: NAME             /* NAME is a string */
		{ $$ = SimpleVar_create($1); }
    | var '[' expr ']'
   		{ $$ = SubscriptVar_create($1, $3); }
    | var '.' var
   		{ $$ = FieldVar_create($1, $3); }
    ;
	
constant	: INT
				{ $$ = IntExpr_create($1); }
			| FLOAT
				{ $$ = FloatExpr_create($1); }
			| CHAR
				{ $$ = CharExpr_create($1); }
;	
			
%%

extern FILE *yyin;

void warning(char *s, int line)
{
	fprintf(stderr, "Warning:\t%d: %s\n", line, s);
}

int yyerror(char *s)
{
	int token_start;
	int token_size;
	
	token_size = strlen(yytext);
	token_start = tokenpos - token_size;

	fprintf(stderr, "%d: %s:\n%s\n", yylineno, s, linebuf);
	fprintf(stderr, "%*s", token_start, " ");
	do
	{
		fprintf(stderr, "^");
	}
	while(--token_size > 0);
	
	fprintf(stderr, "\n");
} 

int yywrap()
{
        return 1;
} 

main()
{
	int result;
	
	result = yyparse();
	
	if(result == 0)
	{
		printf("Syntax analysis complete. No errors found\n");
		
		setPrinter("tree.xml");
		printProgram(root);
	}
		
	return 0;
}

